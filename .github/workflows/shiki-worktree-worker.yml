name: Shiki - Worktree Worker

# タスクごとの worktree ワーカー
# DAG Executor または手動でディスパッチされる

on:
  workflow_dispatch:
    inputs:
      task_id:
        description: "Task ID (e.g., T-0001)"
        required: true
        type: string
      worktree_branch:
        description: "Git branch for this worktree (e.g., shiki/task-T-0001)"
        required: true
        type: string
      engine:
        description: "Execution engine (codex, claude-team, claude-leader, claude-member)"
        required: true
        type: choice
        options:
          - codex
          - claude-team
          - claude-leader
          - claude-member
        default: codex
      dag_file:
        description: "Path to DAG file (optional)"
        required: false
        type: string
      node_id:
        description: "DAG node ID (optional)"
        required: false
        type: string

permissions:
  contents: write
  issues: write
  pull-requests: write

jobs:
  worker:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # ---------------------------------------------------------------
      # Step 1: Setup worktree branch
      # ---------------------------------------------------------------
      - name: Setup worktree branch
        id: setup
        shell: bash
        run: |
          BRANCH="${{ inputs.worktree_branch }}"
          TASK_ID="${{ inputs.task_id }}"

          echo "Setting up branch: $BRANCH for task: $TASK_ID"

          # Create or checkout the worktree branch
          if git rev-parse --verify "origin/$BRANCH" >/dev/null 2>&1; then
            git checkout "$BRANCH"
            echo "Checked out existing branch: $BRANCH"
          else
            git checkout -b "$BRANCH"
            echo "Created new branch: $BRANCH"
          fi

          # Read task file
          TASK_FILE=".shiki/tasks/${TASK_ID}.json"
          if [ ! -f "$TASK_FILE" ]; then
            echo "::error::Task file not found: $TASK_FILE"
            exit 1
          fi

          echo "task_file=$TASK_FILE" >> "$GITHUB_OUTPUT"

          # Extract task details
          TITLE=$(python3 -c "import json; print(json.load(open('$TASK_FILE')).get('title',''))")
          ACCEPTANCE=$(python3 -c "import json; print('\n'.join(json.load(open('$TASK_FILE')).get('acceptance',[])))")
          CONTRACT=$(python3 -c "import json; print(json.load(open('$TASK_FILE')).get('context',{}).get('contract_ref',''))")
          TARGET_FILES=$(python3 -c "import json; print(' '.join(json.load(open('$TASK_FILE')).get('context',{}).get('target_files',[])))")
          BUDGET_MAX=$(python3 -c "import json; print(json.load(open('$TASK_FILE')).get('budget',{}).get('max_tokens', 100000))")

          echo "title=$TITLE" >> "$GITHUB_OUTPUT"
          echo "acceptance<<EOFACC" >> "$GITHUB_OUTPUT"
          echo "$ACCEPTANCE" >> "$GITHUB_OUTPUT"
          echo "EOFACC" >> "$GITHUB_OUTPUT"
          echo "contract=$CONTRACT" >> "$GITHUB_OUTPUT"
          echo "target_files=$TARGET_FILES" >> "$GITHUB_OUTPUT"
          echo "budget_max=$BUDGET_MAX" >> "$GITHUB_OUTPUT"

          # Mark task as in_progress
          python3 << PYEOF
          import json
          from datetime import datetime, timezone
          with open("$TASK_FILE", encoding="utf-8") as f:
              task = json.load(f)
          task["status"] = "in_progress"
          task["claimed_by"] = "${{ inputs.engine }}-gh-action"
          task["updated_at"] = datetime.now(timezone.utc).isoformat()
          task["worktree_branch"] = "$BRANCH"
          with open("$TASK_FILE", "w", encoding="utf-8") as f:
              json.dump(task, f, indent=2, ensure_ascii=False)
          PYEOF

          git add "$TASK_FILE"
          git config user.name "shiki-bot"
          git config user.email "shiki-bot@users.noreply.github.com"
          git commit -m "shiki: mark $TASK_ID as in_progress" || true

      # ---------------------------------------------------------------
      # Step 2a: Run Codex engine
      # ---------------------------------------------------------------
      - name: "θ₄ EXECUTE - Codex implementation"
        if: inputs.engine == 'codex'
        uses: openai/codex-action@v1
        with:
          openai-api-key: ${{ secrets.OPENAI_API_KEY }}
          prompt: |
            You are Codex, the implementation engine running in θ₄ EXECUTE phase.
            Read AGENTS.md for conventions.

            **Task:** ${{ steps.setup.outputs.title }}
            **Task ID:** ${{ inputs.task_id }}
            **Task file:** ${{ steps.setup.outputs.task_file }}
            **Target files:** ${{ steps.setup.outputs.target_files }}
            **Contract ref:** ${{ steps.setup.outputs.contract }}
            **Budget limit:** ${{ steps.setup.outputs.budget_max }} tokens

            **Instructions:**
            1. Read the full task from ${{ steps.setup.outputs.task_file }}
            2. If a contract is referenced, read .shiki/contracts/${{ steps.setup.outputs.contract }}.json
            3. Implement the minimal changes to satisfy acceptance criteria
            4. Run acceptance criteria:
            ${{ steps.setup.outputs.acceptance }}
            5. Write a report to .shiki/reports/${{ inputs.task_id }}.md
            6. Update the task file: set status=review, update outputs and updated_at

            **Constraints:**
            - Keep changes minimal and task-scoped
            - Do not modify contracts unless the task explicitly requires it
            - Do not exceed the budget limit
            - Stay within the worktree branch scope
          sandbox: workspace-write
          output-file: codex-output-${{ inputs.task_id }}.md

      # ---------------------------------------------------------------
      # Step 2b: Run Claude engine
      # ---------------------------------------------------------------
      - name: "θ₄ EXECUTE - Claude implementation"
        if: inputs.engine != 'codex'
        uses: anthropics/claude-code-action@v1
        with:
          anthropic_api_key: ${{ secrets.ANTHROPIC_API_KEY }}
          prompt: |
            You are Claude, the implementation engine running in θ₄ EXECUTE phase.
            Read CLAUDE.md and AGENTS.md for conventions.

            **Task:** ${{ steps.setup.outputs.title }}
            **Task ID:** ${{ inputs.task_id }}
            **Task file:** ${{ steps.setup.outputs.task_file }}
            **Target files:** ${{ steps.setup.outputs.target_files }}
            **Contract ref:** ${{ steps.setup.outputs.contract }}
            **Budget limit:** ${{ steps.setup.outputs.budget_max }} tokens

            **Instructions:**
            1. Read the full task from ${{ steps.setup.outputs.task_file }}
            2. If a contract is referenced, read .shiki/contracts/${{ steps.setup.outputs.contract }}.json
            3. Implement the minimal changes to satisfy acceptance criteria
            4. Run acceptance criteria:
            ${{ steps.setup.outputs.acceptance }}
            5. Write a report to .shiki/reports/${{ inputs.task_id }}.md using templates/REPORT.template.md format
            6. Update the task file: set status=review, update outputs and updated_at

            **Constraints:**
            - Keep changes minimal and task-scoped
            - Do not modify contracts unless the task explicitly requires it
            - Do not exceed the budget limit
            - Stay within the worktree branch scope
          claude_args: >-
            --max-turns 8

      # ---------------------------------------------------------------
      # Step 3: Run acceptance criteria
      # ---------------------------------------------------------------
      - name: Run acceptance criteria
        id: acceptance
        shell: bash
        continue-on-error: true
        run: |
          TASK_FILE="${{ steps.setup.outputs.task_file }}"
          RESULT="pass"

          python3 << 'PYEOF'
          import json
          import subprocess
          import sys

          task_file = "${{ steps.setup.outputs.task_file }}"
          with open(task_file, encoding="utf-8") as f:
              task = json.load(f)

          acceptance = task.get("acceptance", [])
          if not acceptance:
              print("No acceptance criteria defined, skipping")
              sys.exit(0)

          failed = []
          for i, cmd in enumerate(acceptance):
              print(f"\n--- Acceptance [{i+1}/{len(acceptance)}]: {cmd}")
              result = subprocess.run(cmd, shell=True, capture_output=True, text=True)
              if result.returncode != 0:
                  print(f"  FAILED (exit {result.returncode})")
                  if result.stderr:
                      print(f"  stderr: {result.stderr[:500]}")
                  failed.append(cmd)
              else:
                  print("  PASSED")

          if failed:
              print(f"\n{len(failed)}/{len(acceptance)} acceptance criteria failed")
              sys.exit(1)
          else:
              print(f"\nAll {len(acceptance)} acceptance criteria passed")
          PYEOF

          echo "result=$?" >> "$GITHUB_OUTPUT"

      # ---------------------------------------------------------------
      # Step 4: Update task status and create report
      # ---------------------------------------------------------------
      - name: Update task status
        shell: bash
        run: |
          TASK_FILE="${{ steps.setup.outputs.task_file }}"
          TASK_ID="${{ inputs.task_id }}"
          ACCEPTANCE_RESULT="${{ steps.acceptance.outcome }}"

          python3 << PYEOF
          import json
          from datetime import datetime, timezone

          task_file = "$TASK_FILE"
          with open(task_file, encoding="utf-8") as f:
              task = json.load(f)

          if "$ACCEPTANCE_RESULT" == "success":
              task["status"] = "review"
          else:
              task["status"] = "failed"

          task["updated_at"] = datetime.now(timezone.utc).isoformat()
          task["theta_phase"] = "execute"

          with open(task_file, "w", encoding="utf-8") as f:
              json.dump(task, f, indent=2, ensure_ascii=False)

          # Ensure report exists
          import os
          report_path = f".shiki/reports/{task['id']}.md"
          if not os.path.exists(report_path):
              with open(report_path, "w", encoding="utf-8") as rf:
                  rf.write(f"# Report: {task['id']}\\n\\n")
                  rf.write(f"**Task:** {task.get('title', '')}\\n")
                  rf.write(f"**Status:** {task['status']}\\n")
                  rf.write(f"**Engine:** ${{ inputs.engine }}\\n")
                  rf.write(f"**Acceptance:** {'PASSED' if '$ACCEPTANCE_RESULT' == 'success' else 'FAILED'}\\n")
                  rf.write(f"**Updated:** {task['updated_at']}\\n")
          PYEOF

      # ---------------------------------------------------------------
      # Step 5: Apply labels
      # ---------------------------------------------------------------
      - name: Update labels
        shell: bash
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          TASK_FILE="${{ steps.setup.outputs.task_file }}"
          ACCEPTANCE_RESULT="${{ steps.acceptance.outcome }}"

          # Find related issue (if any)
          ISSUE=$(python3 -c "
          import json
          t = json.load(open('$TASK_FILE'))
          links = t.get('links', [])
          for l in links:
              if l.startswith('#'):
                  print(l[1:])
                  break
          " 2>/dev/null || echo "")

          if [ -n "$ISSUE" ]; then
            if [ "$ACCEPTANCE_RESULT" = "success" ]; then
              gh issue edit "$ISSUE" --add-label "status/review,theta/4-execute" \
                --remove-label "status/in-progress" \
                --repo "${{ github.repository }}" || true
            else
              gh issue edit "$ISSUE" --add-label "status/failed,theta/4-execute" \
                --remove-label "status/in-progress" \
                --repo "${{ github.repository }}" || true
            fi
          fi

      # ---------------------------------------------------------------
      # Step 6: Commit and push results
      # ---------------------------------------------------------------
      - name: Commit and push results
        shell: bash
        run: |
          git config user.name "shiki-bot"
          git config user.email "shiki-bot@users.noreply.github.com"
          git add -A
          git diff --cached --quiet || git commit -m "shiki(${{ inputs.engine }}): complete task ${{ inputs.task_id }}"
          git push origin "${{ inputs.worktree_branch }}" || git push --set-upstream origin "${{ inputs.worktree_branch }}"

      # ---------------------------------------------------------------
      # Step 7: Update DAG node status (if part of a DAG)
      # ---------------------------------------------------------------
      - name: Update DAG node status
        if: inputs.dag_file != '' && inputs.node_id != ''
        shell: bash
        run: |
          DAG_FILE="${{ inputs.dag_file }}"
          NODE_ID="${{ inputs.node_id }}"
          ACCEPTANCE_RESULT="${{ steps.acceptance.outcome }}"

          if [ -f "$DAG_FILE" ]; then
            python3 << PYEOF
          import json
          from datetime import datetime, timezone

          with open("$DAG_FILE", encoding="utf-8") as f:
              dag = json.load(f)

          for node in dag["nodes"]:
              if node["node_id"] == "$NODE_ID":
                  if "$ACCEPTANCE_RESULT" == "success":
                      node["status"] = "completed"
                  else:
                      node["status"] = "failed"
                  break

          dag["metadata"]["updated_at"] = datetime.now(timezone.utc).isoformat()

          with open("$DAG_FILE", "w", encoding="utf-8") as f:
              json.dump(dag, f, indent=2, ensure_ascii=False)
          PYEOF

            git add "$DAG_FILE"
            git commit -m "shiki: update DAG node $NODE_ID status" || true
            git push || true
          fi
